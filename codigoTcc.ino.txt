#include <Adafruit_GFX.h>    // Biblioteca para gráficos no display OLED
#include <Adafruit_SSD1306.h> // Biblioteca para controle do display OLED
#include "MAX30105.h"        // Biblioteca para sensor MAX30105 (PPG - fotopletismografia)
#include "heartRate.h"       // Biblioteca para cálculo de frequência cardíaca
#include <WiFi.h>            // Biblioteca para conexão WiFi
#include <PubSubClient.h>    // Biblioteca para protocolo MQTT

MAX30105 particleSensor;     // Objeto para o sensor MAX30105

// Configurações da rede Wi-Fi
const char* ssid = "MPHUMAPO_2G";     // SSID da rede WiFi
const char* password = "MPHUMAPO";     // Senha da rede WiFi
const char* mqttServer = "192.168.0.64"; // Endereço do servidor MQTT
int port = 1883;                       // Porta do servidor MQTT
String stMac;                          // Para armazenar endereço MAC
char mac[50];                          // Buffer para endereço MAC como char array
char clientId[50];                     // ID do cliente MQTT

// Configurações do Buzzer
#define BUZZER_PIN 4  // Pino GPIO onde o buzzer está conectado

// Configurações do sensor GSR (Resistência Galvânica da Pele)
const int sensorPin = 34; // Pino analógico do sensor GSR
const int bufferSize = 10; // Tamanho do buffer para média móvel simples (SMA)
float sensorBuffer[bufferSize]; // Buffer para armazenar valores do GSR
int bufferIndex = 0; // Índice atual no buffer

// Variáveis para cálculo de batimentos cardíacos
const byte RATE_SIZE = 4; // Tamanho do array para média de batimentos
byte rates[RATE_SIZE];    // Array para armazenar batimentos
byte rateSpot = 0;        // Posição atual no array rates
long lastBeat = 0;        // Tempo do último batimento detectado
float beatsPerMinute;     // BPM atual
int beatAvg;              // Média de BPM

// Variáveis para cálculo de SpO2 (Saturação de Oxigênio)
double avered = 0;        // Média do sinal vermelho (RED)
double aveir = 0;         // Média do sinal infravermelho (IR)
double sumirrms = 0;      // Soma dos quadrados do IR
double sumredrms = 0;     // Soma dos quadrados do RED

double SpO2 = 0;          // Valor calculado de SpO2
double ESpO2 = 60.0;      // Valor estimado de SpO2 (valor inicial)
double FSpO2 = 0.7;       // Fator de filtro para SpO2 estimado
double frate = 0.95;      // Filtro passa-baixa para valores IR/RED
int i = 0;                // Contador de amostras
int Num = 30;             // Número de amostras para calcular SpO2

#define FINGER_ON 7000    // Valor mínimo de IR para detectar dedo no sensor
#define MINIMUM_SPO2 60.0 // Valor mínimo plausível de SpO2

// Configuração de intervalo para publicação MQTT
unsigned long lastPublishTime = 0;
const long publishInterval = 10000;  // Intervalo de 10 segundos

// Configurações do display OLED
#define SCREEN_WIDTH 128  // Largura do display em pixels
#define SCREEN_HEIGHT 64  // Altura do display em pixels
#define OLED_RESET    -1  // Pino de reset (não utilizado)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); 
// Bitmaps para exibição no OLED (coração, SpO2, GSR)
static const unsigned char PROGMEM logo2_bmp[] =
{
    0x00, 0x00, 0x00, 0x07, 0x03, 0x00, 0x1f, 0x8f, 0xc0, 0x1f, 0xdf, 0xe0, 0x3f, 0xff, 0xe0, 0x3f, 
    0xff, 0xf0, 0x7f, 0xdf, 0xf0, 0x7f, 0xdf, 0xf0, 0x3f, 0x57, 0xe0, 0x1f, 0x17, 0xe0, 0x00, 0x00, 
    0x00, 0x0f, 0xb7, 0x80, 0x07, 0xef, 0x00, 0x03, 0xef, 0x00, 0x01, 0xfe, 0x00, 0x01, 0xfc, 0x00, 
    0x00, 0xf8, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// LOGO CORAÇÃO 2     -- --COLOQUEI AQUI DE NOGO A FUNÇÃO DA LOGO DO CORAÇÃO
static const unsigned char PROGMEM logo3_bmp[] =
{
    0x00, 0x00, 0x00, 0x07, 0x03, 0x00, 0x1f, 0x8f, 0xc0, 0x1f, 0xdf, 0xe0, 0x3f, 0xff, 0xe0, 0x3f, 
    0xff, 0xf0, 0x7f, 0xdf, 0xf0, 0x7f, 0xdf, 0xf0, 0x3f, 0x57, 0xe0, 0x1f, 0x17, 0xe0, 0x00, 0x00, 
    0x00, 0x0f, 0xb7, 0x80, 0x07, 0xef, 0x00, 0x03, 0xef, 0x00, 0x01, 0xfe, 0x00, 0x01, 0xfc, 0x00, 
    0x00, 0xf8, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// LOGO SP02 
static const unsigned char PROGMEM O2_bmp[] = 
{
    0x00, 0x00, 0x00, 0x01, 0xe1, 0xe0, 0x07, 0xfb, 0xf0, 0x0f, 0xff, 0xf0, 0x1f, 0x7f, 0xf0, 0x3c, 
    0x1f, 0xf0, 0x39, 0xcf, 0xe0, 0x7b, 0xef, 0x80, 0x73, 0xef, 0x80, 0x7b, 0xe7, 0x80, 0x79, 0xcb, 
    0x80, 0x3c, 0x1b, 0x00, 0x3f, 0xf7, 0x00, 0x1f, 0xef, 0x00, 0x1f, 0xc2, 0x00, 0x3f, 0xf8, 0x00, 
    0x3f, 0xe0, 0x00, 0x3f, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const unsigned char PROGMEM gsr_sensor[] = 
{
    0x00, 0x30, 0x00, 0x00, 0xf8, 0x00, 0x01, 0x4e, 0x00, 0x01, 0x4a, 0x00, 0x07, 0x7a, 0x00, 0x0f, 
    0x7a, 0x00, 0x09, 0xfa, 0x00, 0x09, 0xfb, 0x80, 0x09, 0xf3, 0xc0, 0x09, 0xd2, 0x40, 0x08, 0x92, 
    0x40, 0x08, 0x92, 0x40, 0x08, 0x90, 0x40, 0x08, 0x90, 0x40, 0x0c, 0x90, 0xc0, 0x04, 0x50, 0x80, 
    0x06, 0x71, 0x80, 0x03, 0xff, 0x00, 0x03, 0x03, 0x00, 0x03, 0xff, 0x00, 0x01, 0xfe, 0x00
};

// Objetos para WiFi e MQTT
WiFiClient espClient;
PubSubClient client(espClient);

void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Conectando-se a ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi conectado");
  Serial.println("Endereço IP: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  // Função para tratar mensagens recebidas (não implementada neste código)
}

void reconnect() {
  // Reconecta ao servidor MQTT se a conexão for perdida
  while (!client.connected()) {
    Serial.print("Tentando se reconectar ao servidor MQTT...");
    if (client.connect(clientId)) {
      Serial.println("Conectado");
    } else {
      Serial.print("Falha na conexão, rc=");
      Serial.print(client.state());
      Serial.println(" Tentando novamente em 5 segundos");
      delay(5000);
    }
  }
}

float calculateSMA(float *values, int numValues) {
  // Calcula a média móvel simples (SMA) dos valores
  float sum = 0;
  for (int i = 0; i < numValues; i++) {
    sum += values[i];
  }
  return sum / numValues;
}

void setup() {
  Serial.begin(115200); // Inicia comunicação serial com baud rate 115200
  setup_wifi();         // Conecta ao WiFi
  client.setServer(mqttServer, port);
  client.setCallback(callback);

  // Configura ID do cliente MQTT baseado no MAC address
  stMac = WiFi.macAddress();
  stMac.toCharArray(mac, 50);
  sprintf(clientId, "ESP32Client-%s", mac);

  // Inicializa o display OLED
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C); 
  display.display();
  delay(3000);
  
  // Inicializa o sensor MAX30105
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("Não foi possível encontrar o MAX30102");
    while (1); // Loop infinito se o sensor não for encontrado
  }

  // Configura parâmetros do sensor MAX30105
  byte ledBrightness = 0x7F; // Intensidade do LED (127 em decimal)
  byte sampleAverage = 4;     // Número de amostras para média
  byte ledMode = 2;          // Modo de operação (RED + IR)
  int sampleRate = 800;       // Taxa de amostragem em Hz
  int pulseWidth = 215;       // Largura de pulso em microsegundos
  int adcRange = 16384;       // Faixa do ADC
  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange); 
  particleSensor.enableDIETEMPRDY(); // Habilita leitura de temperatura

  // Configura intensidade dos LEDs
  particleSensor.setPulseAmplitudeRed(0x0A); // Vermelho com intensidade baixa
  particleSensor.setPulseAmplitudeGreen(0);  // LED verde desligado
}

void loop() {
  // Verifica e mantém conexão MQTT
  if (!client.connected()) {
    reconnect();        
  }
  client.loop();

  // Leitura e processamento do sensor GSR
  float sensorValue = analogRead(sensorPin); // Lê valor bruto do GSR
  sensorBuffer[bufferIndex] = sensorValue;   // Armazena no buffer
  bufferIndex = (bufferIndex + 1) % bufferSize; // Atualiza índice circular

  // Cálculo de condutância e resistência da pele
  float smaValue = calculateSMA(sensorBuffer, bufferSize); // Média móvel
  float voltage = smaValue * (3.3 / 4095); // Converte para tensão (0-3.3V)
  float conductance = 1000 / voltage;      // Calcula condutância (µS)
  float resistance = voltage / (0.001 * conductance); // Calcula resistência (kΩ)

  // Exibe valores no monitor serial
  Serial.print("Valor Sensor GSR: " + String(sensorValue));
  Serial.print("condutância: " + String(conductance));

  // Leitura do sensor PPG (MAX30105)
  long irValue = particleSensor.getIR(); // Lê valor IR para detectar dedo
  
  if (irValue > FINGER_ON ) { // Se dedo está no sensor
    if (checkForBeat(irValue) == true) { // Detecta batimento cardíaco
      long delta = millis() - lastBeat;  // Calcula intervalo entre batimentos
      lastBeat = millis();               // Atualiza tempo do último batimento
      beatsPerMinute = 60 / (delta / 1000.0); // Calcula BPM
      
      if (beatsPerMinute < 255 && beatsPerMinute > 20) { // Filtra valores inválidos
        rates[rateSpot++] = (byte)beatsPerMinute; // Armazena no array
        rateSpot %= RATE_SIZE;                    // Índice circular
        beatAvg = 0;                              // Calcula média
        for (byte x = 0 ; x < RATE_SIZE ; x++) beatAvg += rates[x];
        beatAvg /= RATE_SIZE;
      }

      // Atualiza display OLED
      display.clearDisplay();
      display.drawBitmap(0, 0, logo3_bmp, 21, 21, WHITE); // Ícone de coração
      display.setTextSize(2);
      display.setTextColor(WHITE);

      // Exibe BPM
      display.setCursor(30, 0); 
      display.print(beatAvg); 
      display.println(" BPM");

      // Exibe SpO2
      display.drawBitmap(0, 22, O2_bmp, 21, 21, WHITE); // Ícone SpO2
      display.setCursor(30, 22);
      if (beatAvg > 30) display.print(String(ESpO2) + "%");
      else display.print("---- %" );

      // Exibe GSR
      display.drawBitmap(0, 42, gsr_sensor, 21, 21, WHITE); // Ícone GSR
      display.setCursor(30, 42);
      display.print(conductance); // Valor de condutância
      display.print(" uS");        // Unidade (microsiemens)

      display.display(); // Atualiza display
    }

    // Cálculo de SpO2
    uint32_t ir, red;
    double fred, fir;
    particleSensor.check(); // Verifica novos dados no sensor
    
    if (particleSensor.available()) {
      i++;
      ir = particleSensor.getFIFOIR();  // Lê valor IR do buffer FIFO
      red = particleSensor.getFIFORed(); // Lê valor RED do buffer FIFO
      fir = (double)ir;
      fred = (double)red;
      // Filtro passa-baixa para os sinais
      aveir = aveir * frate + (double)ir * (1.0 - frate);
      avered = avered * frate + (double)red * (1.0 - frate);
      
      // Cálculo RMS para razão R
      sumirrms += (fir - aveir) * (fir - aveir);
      sumredrms += (fred - avered) * (fred - avered);

      if ((i % Num) == 0) { // A cada Num amostras, calcula SpO2
        double R = (sqrt(sumirrms) / aveir) / (sqrt(sumredrms) / avered);
        SpO2 = -23.3 * (R - 0.4) + 120; // Fórmula empírica para SpO2
        ESpO2 = FSpO2 * ESpO2 + (1.0 - FSpO2) * SpO2; // Filtro de estimativa
        
        // Limita valores de SpO2
        if (ESpO2 <= MINIMUM_SPO2) ESpO2 = MINIMUM_SPO2; 
        if (ESpO2 > 100) ESpO2 = 99.9;
        
        // Reinicia variáveis para próximo cálculo
        sumredrms = 0.0; sumirrms = 0.0; SpO2 = 0;
        i = 0;
      }
      particleSensor.nextSample(); // Próxima amostra no FIFO
    }
    // Exibe valores no monitor serial
    Serial.print(" Bpm:" + String(beatAvg));
    if (beatAvg > 30)  Serial.println(", SPO2:" + String(ESpO2));
    else Serial.println(", SPO2:" + String(ESpO2));
  } else {
    // Se dedo não está no sensor, reinicia variáveis e mostra mensagem
    for (byte rx = 0 ; rx < RATE_SIZE ; rx++) rates[rx] = 0;
    beatAvg = 0; rateSpot = 0; lastBeat = 0;
    avered = 0; aveir = 0; sumirrms = 0; sumredrms = 0;
    SpO2 = 0; ESpO2 = 90.0;
    display.clearDisplay();
    display.setTextSize(2);
    display.setTextColor(WHITE);
    display.setCursor(30, 5);
    display.println("coloque o");
    display.setCursor(30, 35);
    display.println("Dispositivo");
    display.display();
  }
  // Publica dados via MQTT em intervalos regulares
  if (millis() - lastPublishTime >= publishInterval) {
    bool condicoesAtendidas = (irValue > FINGER_ON) && (sensorValue < 4094);
    
    if (condicoesAtendidas) {
       client.publish("topico/NodeRed/BPM", String(beatAvg).c_str());
       client.publish("topico/NodeRed/SpO2", String(ESpO2).c_str());
       client.publish("topico/NodeRed/Condutancia", String(conductance).c_str());
    } else {
       Serial.print("Ambas as condições são falsas.\n");
    }   
    lastPublishTime = millis(); // Reinicia temporizador
  }
  // Detecção de sonolência
  if ((beatAvg < 60) && ((conductance >= 357) && (conductance <= 370))) {
    digitalWrite(BUZZER_PIN, HIGH);  // Aciona buzzer se sonolência detectada
    Serial.println("Sonolência detectada! Buzzer acionado.");
  } else {
    digitalWrite(BUZZER_PIN, LOW);   // Desliga buzzer
  }
}